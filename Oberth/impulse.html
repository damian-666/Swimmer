<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>3D Orbital Simulation with Impulse Kicker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
        }

        #ui button,
        #ui input {
            margin-bottom: 5px;
            display: block;
            width: 100%;
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        #text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #info {
            display: block;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <label for="impulseSlider">Impulse Magnitude:</label>
        <input type="range" id="impulseSlider" min="0" max="50" step="1" value="10"><br>
        <button id="impulseButton">Apply Impulse</button>
        <span id="info"></span>
    </div>

    <!-- Include Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <!-- Include OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background for space

        // Add AxesHelper for visualization
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Add directional light (sunlight)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Adjust wireframe material settings
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0x2233ff,
            wireframe: true,
            wireframeLinewidth: 2,
            emissive: 0x112244,
            transparent: true,
            opacity: 0.9
        });

        // Constants
        const G = 6.67430e-11; // Gravitational constant (m^3 kg^-1 s^-2)
        const earthMass = 5.972e24; // Mass of Earth (kg)
        const earthRadius = 6.371e6; // Radius of Earth (m)
        const timeStep = 0.1; // seconds per simulation step
        const scale = 1e-6; // Scale factor for rendering

        // Create camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0 * scale, -1e7 * scale, 3e7 * scale); // Apply scaling
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 0);

        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable inertial damping
        controls.dampingFactor = 0.05;
        controls.zoomSpeed = 1.2;
        controls.enablePan = false; // Disable panning to prevent unnecessary movement

        // Add Earth
        const earthGeometry = new THREE.SphereGeometry(earthRadius * scale, 64, 64);
        const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earthMesh);

        // Great circles (geodesic lines)
        const circleMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        for (let i = 0; i < 12; i++) {
            const circlePoints = [];
            const segments = 128;
            const radius = earthRadius * scale;
            for (let j = 0; j <= segments; j++) {
                const theta = (j / segments) * 2 * Math.PI;
                const x = radius * Math.cos(theta);
                const y = radius * Math.sin(theta);
                circlePoints.push(new THREE.Vector3(x, y, 0));
            }
            const circleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
            const circle = new THREE.Line(circleGeometry, circleMaterial);
            circle.rotation.x = Math.PI / 2;
            circle.rotation.z = (Math.PI / 6) * i;
            scene.add(circle);
        }

        // Satellite (200 kg)
        const satelliteMass = 200; // kg
        const orbitAltitude = 200000; // Orbit altitude above Earth's surface (200 km)
        const orbitRadius = earthRadius + orbitAltitude; // Orbit radius from Earth's center (m)
        const satellitePosition = new THREE.Vector3(orbitRadius, 0, 0); // Starting position
        const orbitalSpeed = Math.sqrt(G * earthMass / orbitRadius); // m/s
        const satelliteVelocity = new THREE.Vector3(0, orbitalSpeed, 0);

        // Kicker (10 kg)
        const kickerMass = 10; // kg
        const kickerOffset = new THREE.Vector3(0, 0, 10000); // Offset from satellite (10 km)
        const kickerPosition = satellitePosition.clone().add(kickerOffset);
        const kickerVelocity = satelliteVelocity.clone();

        // Create visual representations
        const satelliteSize = 1e5 * scale;
        const satelliteGeometry = new THREE.BoxGeometry(satelliteSize, satelliteSize, satelliteSize);
        const satelliteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const satelliteMesh = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
        scene.add(satelliteMesh);

        const kickerSize = 5e4 * scale;
        const kickerGeometry = new THREE.BoxGeometry(kickerSize, kickerSize, kickerSize);
        const kickerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const kickerMesh = new THREE.Mesh(kickerGeometry, kickerMaterial);
        scene.add(kickerMesh);

        // UI Elements
        const impulseSlider = document.getElementById('impulseSlider');
        let impulseApplied = false;
        document.getElementById('impulseButton').addEventListener('click', () => {
            impulseApplied = true;
        });

        // Simulation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update positions and velocities
            updatePositions();

            // Update mesh positions
            satelliteMesh.position.copy(satellitePosition.clone().multiplyScalar(scale));
            kickerMesh.position.copy(kickerPosition.clone().multiplyScalar(scale));

            // Render scene
            controls.update();
            renderer.render(scene, camera);
        }

        function updatePositions() {
            // Gravitational force on satellite
            const satDistance = satellitePosition.length();
            const satForceMag = (G * earthMass * satelliteMass) / (satDistance * satDistance);
            const satAcceleration = satellitePosition.clone().negate().normalize().multiplyScalar(satForceMag / satelliteMass);

            // Gravitational force on kicker
            const kickDistance = kickerPosition.length();
            const kickForceMag = (G * earthMass * kickerMass) / (kickDistance * kickDistance);
            const kickAcceleration = kickerPosition.clone().negate().normalize().multiplyScalar(kickForceMag / kickerMass);

            // Linear constraint force between satellite and kicker
            const separation = kickerPosition.clone().sub(satellitePosition);
            const separationDistance = separation.length();
            const maxSeparation = 2e4; // Maximum separation distance (20 km)

            if (separationDistance > maxSeparation) {
                const constraintForceMag = 0.01 * (separationDistance - maxSeparation);
                const constraintForce = separation.normalize().multiplyScalar(-constraintForceMag);

                // Apply to satellite
                const satConstraintAccel = constraintForce.clone().divideScalar(satelliteMass);
                satelliteVelocity.add(satConstraintAccel.multiplyScalar(timeStep));

                // Apply to kicker
                const kickConstraintAccel = constraintForce.clone().negate().divideScalar(kickerMass);
                kickerVelocity.add(kickConstraintAccel.multiplyScalar(timeStep));
            }

            // Apply impulse when button is pressed
            if (impulseApplied) {
                const impulseDirection = satellitePosition.clone().normalize();
                const impulseMagnitude = parseFloat(impulseSlider.value);
                satelliteVelocity.add(impulseDirection.multiplyScalar(impulseMagnitude / satelliteMass));
                kickerVelocity.add(impulseDirection.clone().multiplyScalar(-impulseMagnitude / kickerMass));
                impulseApplied = false;
            }

            // Update velocities
            satelliteVelocity.add(satAcceleration.multiplyScalar(timeStep));
            kickerVelocity.add(kickAcceleration.multiplyScalar(timeStep));

            // Update positions
            satellitePosition.add(satelliteVelocity.clone().multiplyScalar(timeStep));
            kickerPosition.add(kickerVelocity.clone().multiplyScalar(timeStep));
        }

        // Start animation
        animate();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>
